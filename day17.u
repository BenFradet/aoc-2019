input17 = [+1,+330,+331,+332,+109,+3132,+1102,+1,+1182,+16,+1101,+1467,+0,+24,+101,+0,+0,+570,+1006,+570,+36,+101,+0,+571,+0,+1001,+570,-1,+570,+1001,+24,+1,+24,+1105,+1,+18,+1008,+571,+0,+571,+1001,+16,+1,+16,+1008,+16,+1467,+570,+1006,+570,+14,+21102,+58,+1,+0,+1106,+0,+786,+1006,+332,+62,+99,+21102,+1,+333,+1,+21102,+73,+1,+0,+1106,+0,+579,+1101,+0,+0,+572,+1101,+0,+0,+573,+3,+574,+101,+1,+573,+573,+1007,+574,+65,+570,+1005,+570,+151,+107,+67,+574,+570,+1005,+570,+151,+1001,+574,-64,+574,+1002,+574,-1,+574,+1001,+572,+1,+572,+1007,+572,+11,+570,+1006,+570,+165,+101,+1182,+572,+127,+1001,+574,+0,+0,+3,+574,+101,+1,+573,+573,+1008,+574,+10,+570,+1005,+570,+189,+1008,+574,+44,+570,+1006,+570,+158,+1105,+1,+81,+21101,+0,+340,+1,+1106,+0,+177,+21101,+0,+477,+1,+1105,+1,+177,+21101,+514,+0,+1,+21102,+176,+1,+0,+1106,+0,+579,+99,+21102,+1,+184,+0,+1106,+0,+579,+4,+574,+104,+10,+99,+1007,+573,+22,+570,+1006,+570,+165,+1002,+572,+1,+1182,+21102,+1,+375,+1,+21101,+0,+211,+0,+1106,+0,+579,+21101,+1182,+11,+1,+21102,+1,+222,+0,+1106,+0,+979,+21102,+388,+1,+1,+21102,+233,+1,+0,+1105,+1,+579,+21101,+1182,+22,+1,+21101,+244,+0,+0,+1106,+0,+979,+21102,+1,+401,+1,+21101,+255,+0,+0,+1105,+1,+579,+21101,+1182,+33,+1,+21102,+266,+1,+0,+1105,+1,+979,+21102,+1,+414,+1,+21102,+1,+277,+0,+1105,+1,+579,+3,+575,+1008,+575,+89,+570,+1008,+575,+121,+575,+1,+575,+570,+575,+3,+574,+1008,+574,+10,+570,+1006,+570,+291,+104,+10,+21102,+1,+1182,+1,+21101,+313,+0,+0,+1105,+1,+622,+1005,+575,+327,+1101,+0,+1,+575,+21102,+1,+327,+0,+1106,+0,+786,+4,+438,+99,+0,+1,+1,+6,+77,+97,+105,+110,+58,+10,+33,+10,+69,+120,+112,+101,+99,+116,+101,+100,+32,+102,+117,+110,+99,+116,+105,+111,+110,+32,+110,+97,+109,+101,+32,+98,+117,+116,+32,+103,+111,+116,+58,+32,+0,+12,+70,+117,+110,+99,+116,+105,+111,+110,+32,+65,+58,+10,+12,+70,+117,+110,+99,+116,+105,+111,+110,+32,+66,+58,+10,+12,+70,+117,+110,+99,+116,+105,+111,+110,+32,+67,+58,+10,+23,+67,+111,+110,+116,+105,+110,+117,+111,+117,+115,+32,+118,+105,+100,+101,+111,+32,+102,+101,+101,+100,+63,+10,+0,+37,+10,+69,+120,+112,+101,+99,+116,+101,+100,+32,+82,+44,+32,+76,+44,+32,+111,+114,+32,+100,+105,+115,+116,+97,+110,+99,+101,+32,+98,+117,+116,+32,+103,+111,+116,+58,+32,+36,+10,+69,+120,+112,+101,+99,+116,+101,+100,+32,+99,+111,+109,+109,+97,+32,+111,+114,+32,+110,+101,+119,+108,+105,+110,+101,+32,+98,+117,+116,+32,+103,+111,+116,+58,+32,+43,+10,+68,+101,+102,+105,+110,+105,+116,+105,+111,+110,+115,+32,+109,+97,+121,+32,+98,+101,+32,+97,+116,+32,+109,+111,+115,+116,+32,+50,+48,+32,+99,+104,+97,+114,+97,+99,+116,+101,+114,+115,+33,+10,+94,+62,+118,+60,+0,+1,+0,-1,-1,+0,+1,+0,+0,+0,+0,+0,+0,+1,+0,+10,+0,+109,+4,+1202,-3,+1,+587,+20102,+1,+0,-1,+22101,+1,-3,-3,+21101,+0,+0,-2,+2208,-2,-1,+570,+1005,+570,+617,+2201,-3,-2,+609,+4,+0,+21201,-2,+1,-2,+1105,+1,+597,+109,-4,+2105,+1,+0,+109,+5,+2102,+1,-4,+630,+20102,+1,+0,-2,+22101,+1,-4,-4,+21101,+0,+0,-3,+2208,-3,-2,+570,+1005,+570,+781,+2201,-4,-3,+653,+20101,+0,+0,-1,+1208,-1,-4,+570,+1005,+570,+709,+1208,-1,-5,+570,+1005,+570,+734,+1207,-1,+0,+570,+1005,+570,+759,+1206,-1,+774,+1001,+578,+562,+684,+1,+0,+576,+576,+1001,+578,+566,+692,+1,+0,+577,+577,+21101,+702,+0,+0,+1105,+1,+786,+21201,-1,-1,-1,+1105,+1,+676,+1001,+578,+1,+578,+1008,+578,+4,+570,+1006,+570,+724,+1001,+578,-4,+578,+21101,+0,+731,+0,+1106,+0,+786,+1106,+0,+774,+1001,+578,-1,+578,+1008,+578,-1,+570,+1006,+570,+749,+1001,+578,+4,+578,+21101,+0,+756,+0,+1105,+1,+786,+1105,+1,+774,+21202,-1,-11,+1,+22101,+1182,+1,+1,+21102,+1,+774,+0,+1106,+0,+622,+21201,-3,+1,-3,+1106,+0,+640,+109,-5,+2106,+0,+0,+109,+7,+1005,+575,+802,+21002,+576,+1,-6,+20101,+0,+577,-5,+1105,+1,+814,+21101,+0,+0,-1,+21101,+0,+0,-5,+21102,+1,+0,-6,+20208,-6,+576,-2,+208,-5,+577,+570,+22002,+570,-2,-2,+21202,-5,+45,-3,+22201,-6,-3,-3,+22101,+1467,-3,-3,+1201,-3,+0,+843,+1005,+0,+863,+21202,-2,+42,-4,+22101,+46,-4,-4,+1206,-2,+924,+21102,+1,+1,-1,+1105,+1,+924,+1205,-2,+873,+21101,+0,+35,-4,+1105,+1,+924,+2102,+1,-3,+878,+1008,+0,+1,+570,+1006,+570,+916,+1001,+374,+1,+374,+2102,+1,-3,+895,+1102,+2,+1,+0,+1201,-3,+0,+902,+1001,+438,+0,+438,+2202,-6,-5,+570,+1,+570,+374,+570,+1,+570,+438,+438,+1001,+578,+558,+921,+21001,+0,+0,-4,+1006,+575,+959,+204,-4,+22101,+1,-6,-6,+1208,-6,+45,+570,+1006,+570,+814,+104,+10,+22101,+1,-5,-5,+1208,-5,+37,+570,+1006,+570,+810,+104,+10,+1206,-1,+974,+99,+1206,-1,+974,+1102,+1,+1,+575,+21101,+0,+973,+0,+1106,+0,+786,+99,+109,-7,+2105,+1,+0,+109,+6,+21101,+0,+0,-4,+21102,+0,+1,-3,+203,-2,+22101,+1,-3,-3,+21208,-2,+82,-1,+1205,-1,+1030,+21208,-2,+76,-1,+1205,-1,+1037,+21207,-2,+48,-1,+1205,-1,+1124,+22107,+57,-2,-1,+1205,-1,+1124,+21201,-2,-48,-2,+1106,+0,+1041,+21102,+1,-4,-2,+1105,+1,+1041,+21101,+0,-5,-2,+21201,-4,+1,-4,+21207,-4,+11,-1,+1206,-1,+1138,+2201,-5,-4,+1059,+1202,-2,+1,+0,+203,-2,+22101,+1,-3,-3,+21207,-2,+48,-1,+1205,-1,+1107,+22107,+57,-2,-1,+1205,-1,+1107,+21201,-2,-48,-2,+2201,-5,-4,+1090,+20102,+10,+0,-1,+22201,-2,-1,-2,+2201,-5,-4,+1103,+2101,+0,-2,+0,+1106,+0,+1060,+21208,-2,+10,-1,+1205,-1,+1162,+21208,-2,+44,-1,+1206,-1,+1131,+1106,+0,+989,+21102,+1,+439,+1,+1105,+1,+1150,+21101,+0,+477,+1,+1106,+0,+1150,+21102,+1,+514,+1,+21102,+1,+1149,+0,+1105,+1,+579,+99,+21101,+1157,+0,+0,+1106,+0,+579,+204,-2,+104,+10,+99,+21207,-3,+22,-1,+1206,-1,+1138,+1201,-5,+0,+1176,+2102,+1,-4,+0,+109,-6,+2106,+0,+0,+8,+9,+36,+1,+7,+1,+36,+1,+1,+13,+30,+1,+7,+1,+5,+1,+30,+1,+7,+1,+5,+1,+7,+11,+12,+1,+7,+1,+5,+1,+7,+1,+9,+1,+12,+1,+7,+1,+5,+1,+7,+1,+1,+13,+8,+1,+7,+1,+5,+1,+7,+1,+1,+1,+7,+1,+3,+1,+8,+1,+7,+1,+5,+1,+7,+1,+1,+1,+7,+1,+3,+1,+8,+1,+7,+1,+5,+1,+7,+1,+1,+1,+7,+1,+3,+10,+5,+9,+1,+13,+3,+1,+3,+1,+14,+1,+1,+1,+7,+1,+5,+1,+1,+1,+3,+1,+3,+1,+3,+1,+8,+9,+5,+9,+1,+1,+3,+1,+3,+1,+3,+1,+8,+1,+5,+1,+7,+1,+1,+1,+7,+1,+3,+1,+3,+1,+3,+1,+8,+1,+5,+1,+7,+1,+1,+1,+7,+1,+3,+1,+3,+1,+3,+1,+8,+1,+5,+1,+7,+1,+1,+1,+7,+1,+3,+1,+3,+1,+3,+1,+8,+1,+5,+1,+7,+1,+1,+1,+7,+9,+3,+1,+8,+1,+5,+1,+7,+1,+1,+1,+11,+1,+7,+1,+8,+1,+5,+1,+7,+1,+1,+11,+1,+9,+8,+1,+5,+1,+7,+1,+11,+1,+18,+13,+1,+1,+11,+1,+24,+1,+5,+1,+1,+1,+11,+1,+24,+9,+11,+1,+30,+1,+13,+1,+30,+1,+13,+1,+30,+1,+13,+1,+30,+1,+13,+9,+22,+1,+21,+1,+22,+11,+11,+1,+32,+1,+11,+1,+32,+1,+11,+1,+32,+1,+11,+1,+32,+1,+11,+1,+32,+1,+11,+1,+32,+1,+11,+1,+32,+1,+11,+1,+32,+13,+2]

intcode = day9.intCode +0 input17

renderText : [Int] -> Text
renderText is =
  List.map (i -> abs i |> Char.fromNat) is |> Text.fromCharList

text = List.reverse intcode |> renderText

intersection : Nat -> Nat -> Nat -> [Char] -> Boolean
intersection i j wi cs =
  n = List.at (abs ((Nat.toInt j) - +1) * wi + i) cs |> Optional.orDefault ?n
  s = List.at ((j + 1) * wi + i) cs |> Optional.orDefault ?n
  e = List.at (j * wi + i + 1) cs |> Optional.orDefault ?n
  w = List.at (j * wi + (abs ((Nat.toInt i) - +1))) cs |> Optional.orDefault ?n
  List.foldl (b -> c -> b && (c == ?#)) true [n, s, e, w]

width : [Char] -> Nat
width cs =
  go cs i = case cs of
    h +: t | h == ?\n -> (i + 1)
    h +: t -> go t (i + 1)
    _ -> i
  go cs 0

intersections : Text -> [(Nat, Nat)]
intersections t =
  ts = Text.toCharList t
  w = width ts
  go i j cs acc = case cs of
    h +: t | h == ?\n -> go 0 (j + 1) t acc
    h +: t | h == ?# && (intersection i j w ts) -> go (i + 1) j t ((i, j) +: acc)
    h +: t -> go (i + 1) j t acc
    _ -> acc
  go 0 0 ts []

> intersections text
> intersections text |> List.map (p -> case p of (i, j) -> i Nat.* j) |> List.foldl (Nat.+) 0

start : [Char] -> ((Nat, Nat), (Int, Int))
start t =
  go cs i j = case cs of
    h +: t | h == ?^ -> ((i, j), (+0, -1))
    h +: t | h == ?v -> ((i, j), (+0, +1))
    h +: t | h == ?> -> ((i, j), (+1, +0))
    h +: t | h == ?< -> ((i, j), (-1, +0))
    h +: t | h == ?\n -> go t 0 (j + 1)
    h +: t -> go t (i + 1) j
    _ -> ((0, 0), (+0, +0))
  go t 0 0

north : Nat -> Nat -> Nat -> Nat
north i j w = if j == 0 then Nat.maxNat else abs ((Nat.toInt j) + -1) * w + i
south : Nat -> Nat -> Nat -> Nat
south i j w = (j + 1) * w + i
east : Nat -> Nat -> Nat -> Nat
east i j w = j * w + i + 1
west : Nat -> Nat -> Nat -> Nat
west i j w = if i == 0 then Nat.maxNat else j * w + (abs ((Nat.toInt i) + -1))

candidates : Nat -> Nat -> Nat -> [Char] -> [(Int, Int)]
candidates i j w cs =
  flatten [
    List.at (north i j w) cs |> Optional.map (c -> (c, (+0, -1))),
    List.at (south i j w) cs |> Optional.map (c -> (c, (+0, +1))),
    List.at (east i j w) cs |> Optional.map (c -> (c, (+1, +0))),
    List.at (west i j w) cs |> Optional.map (c -> (c, (-1, +0)))
  ] |> filter (v -> case v of (c, nd) -> c == ?#) |> List.map Tuple.at2

find : a -> [a] -> Optional a
find a as = case as of
  h +: t | h == a -> Some h
  h +: t -> find a t
  _ -> None

negate : (Int, Int) -> (Int, Int)
negate p = case p of (i, j) -> (Int.negate i, Int.negate j)

add : (Nat, Nat) -> (Int, Int) -> (Nat, Nat)
add p d = case (p, d) of ((px, py), (dx, dy)) ->
  (day5.abs ((Nat.toInt px) + dx), day5.abs ((Nat.toInt py) + dy))

nextMove : Nat -> [Char] -> ((Nat, Nat), (Int, Int)) -> Optional (((Nat, Nat), (Int, Int)), ((Nat, Nat), (Int, Int)))
nextMove w cs s = case s of ((px, py), (dx, dy)) ->
  cds = candidates px py w cs |> filter (d -> not (d == (negate (dx, dy))))
  find (dx, dy) cds
    |> (o -> Optional.orElse o (List.uncons cds |> Optional.map Tuple.at1))
    |> Optional.map (d -> (add (px, py) d, d))
    |> Optional.map (p -> (p, p))

nextMove' : Nat -> [Char] -> (Nat, (Nat, Nat), (Int, Int)) -> Optional ((Nat, (Nat, Nat), (Int, Int)), (Nat, (Nat, Nat), (Int, Int)))
nextMove' w cs s = case s of (i, (px, py), (dx, dy)) ->
  if i >= 80 then None
  else
    cds = candidates px py w cs |> filter (d -> not (d == (negate (dx, dy))))
    find (dx, dy) cds
      |> (o -> Optional.orElse o (List.uncons cds |> Optional.map Tuple.at1))
      |> Optional.map (d -> (i + 1, add (px, py) d, d))
      |> Optional.map (p -> (p, p))

crossP : (Int, Int) -> (Int, Int) -> Int
crossP p1 p2 = case (p1, p2) of ((x1, y1), (x2, y2)) ->
  (x1 * y2) - (y1 * x2)

--visit : [Char] -> [(Char, Nat)]
visit t =
  w = width t
  s = start t
  go acc e = case acc of (ds, pe) ->
    if pe == e then
      case List.uncons ds of
        Some (h, t) -> (((Tuple.at1 h, (Tuple.at2 h) + 1)) +: t, pe)
        _ -> ([(?R, 1)], pe)
    else
      a = crossP pe e
      c = if a < +0 then ?L else ?R
      ((c, 1) +: ds, e)
  List.unfold s (nextMove w t)
    |> List.map Tuple.at2
    |> List.foldl go ([], Tuple.at2 s)
    |> Tuple.at1
    |> List.reverse

indexOfSlice : [a] -> [a] -> Optional Nat
indexOfSlice sub ls =
  go' ss ls = case (ss, ls) of
    (h1 +: t1, h2 +: t2) | h1 == h2 -> go' t1 t2
    (h1 +: t1, h2 +: t2) -> false
    ([], _) -> true
    _ -> false
  go i ls = case (sub, ls) of
    (h1 +: t1, h2 +: t2) | h1 == h2 -> if go' t1 t2 then Some i else go (i + 1) t2
    (_, h +: t) -> go (i + 1) t
    _ -> None
  go 0 ls

split : [a] -> [a] -> [[a]]
split delim as =
  case indexOfSlice delim as of
    None -> [as]
    Some i ->
      p = List.take i as
      s = List.drop (i + (List.size delim)) as
      p +: split delim s

findPatterns : Nat -> Nat -> [[a]] -> [[[a]]]
findPatterns maxPatterns maxLength ps =
  f h n =
    init = List.take n h
    List.flatMap (split init) ps
      |> filter (l -> List.size l > 0)
      |> findPatterns (abs ((Nat.toInt maxPatterns) + -1)) maxLength
      |> List.map (t -> init +: t)
  case ps of
    [] -> [[]]
    h +: t ->
      if maxPatterns <= 0 then [[]]
      else
        s = List.size h
        List.range 2 (if (maxLength + 1) < (s + 1) then (maxLength + 1) else (s + 1))
          |> List.reverse
          |> List.flatMap (f h)

zipWithIndex : [a] -> [(a, Nat)]
zipWithIndex as =
  go as i acc = case as of
    h +: t -> go t (i + 1) ((h, i) +: acc)
    _ -> acc
  go as 0 [] |> List.reverse

startsWith : [a] -> [a] -> Boolean
startsWith part ps = case (part, ps) of
  (h1 +: t1, h2 +: t2) | h1 == h2 -> startsWith t1 t2
  ([], _) -> true
  _ -> false

mainRoutine : [(Char, Nat)] -> [[(Char, Nat)]] -> [Nat]
mainRoutine ps patterns =
  zipped = zipWithIndex patterns
  go ps acc = case ps of
    [] -> acc
    _ ->
      res =
        zipped
          |> filter (p -> case p of (part, i) -> startsWith part ps)
          |> List.head
          |> Optional.orDefault ([], 0)
      go (List.drop (Tuple.at1 res |> List.size) ps) (Tuple.at2 res +: acc)
  go ps [] |> List.reverse |> List.map (i -> i + 65)

interleave : a -> [a] -> [a]
interleave a as = case as of
  h +: [] -> [h]
  h +: t -> [h, a] ++ interleave a t

toChar : Nat -> [Nat]
toChar n = digits n |> List.map (i -> i + 48)

buildInput : [Nat] -> [[(Char, Nat)]] -> [Nat]
buildInput mainRoutine patterns =
  mr = interleave 44 mainRoutine
  ps =
    List.map (List.flatMap (p -> case p of (c, i) -> [44, Char.toNat c, 44] ++ (toChar i))) patterns
      |> List.map (l -> List.uncons l |> Optional.map Tuple.at2 |> Optional.orDefault [])
      |> interleave [10]
      |> List.flatMap id
  mr ++ [10] ++ ps

text2 = "#######...#####
#.....#...#...#
#.....#...#...#
......#...#...#
......#...###.#
......#.....#.#
^########...#.#
......#.#...#.#
......#########
........#...#..
....#########..
....#...#......
....#...#......
....#...#......
....#####......" |> Text.toCharList

vs = visit text2
> vs
patterns = visit text2 |> (v -> [v]) |> findPatterns 3 5 |> List.head |> Optional.orDefault []
mr = mainRoutine vs patterns
> buildInput mr patterns |> List.map (Char.fromNat) |> take 20

---
widthText2 = width text2
> candidates 10 0 widthText2 text2

---
> north 0 6 widthText2
> List.at (north 0 6 widthText2) text2
> south 0 6 widthText2
> List.at (south 0 6 widthText2) text2
> east 0 6 widthText2
> List.at (east 0 6 widthText2) text2
> west 0 6 widthText2
> List.at (west 0 6 widthText2) text2
